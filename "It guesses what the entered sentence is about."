import os
import torch
import flask
from flask import Flask, request, jsonify, render_template
from transformers import DistilBertTokenizer, DistilBertForSequenceClassification
from pyngrok import ngrok
import logging

# Güvenlik için çevresel değişkenlerden token alma
NGROK_AUTH_TOKEN = os.environ.get('NGROK_AUTH_TOKEN')

# Logging ayarları
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TextClassificationApp:
    def __init__(self, model_path, categories):
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        
        try:
            self.tokenizer = DistilBertTokenizer.from_pretrained(model_path)
            self.model = DistilBertForSequenceClassification.from_pretrained(model_path)
            self.model.to(self.device)
            self.model.eval()
            
            self.categories = categories
            logger.info("Model başarıyla yüklendi.")
        
        except Exception as e:
            logger.error(f"Model yüklenirken hata oluştu: {e}")
            raise

    def predict(self, text):
        try:
            # Tokenize input
            encodings = self.tokenizer(
                text, 
                padding=True, 
                truncation=True, 
                max_length=512, 
                return_tensors="pt"
            ).to(self.device)

            # Tahmin yapma
            with torch.no_grad():
                logits = self.model(**encodings).logits
                probs = torch.nn.functional.softmax(logits, dim=-1)
                top_probs, top_labels = torch.topk(probs, k=3)

            # Tahminleri formatlama
            predictions = [
                {
                    "category": self.categories[label.item()], 
                    "probability": round(prob.item() * 100, 2)
                }
                for prob, label in zip(top_probs[0], top_labels[0])
            ]

            return predictions

        except Exception as e:
            logger.error(f"Tahmin yapılırken hata: {e}")
            return None

def create_app(model_path, categories):
    app = Flask(__name__)
    classifier = TextClassificationApp(model_path, categories)

    @app.route("/")
    def home():
        return "Metin Sınıflandırma Servisi Çalışıyor"

    @app.route("/predict", methods=["POST"])
    def predict():
        try:
            data = request.json
            text = data.get("text", "")

            if not text:
                return jsonify({"error": "Metin boş olamaz"}), 400

            predictions = classifier.predict(text)
            
            if predictions is None:
                return jsonify({"error": "Tahmin yapılamadı"}), 500

            return jsonify({"predictions": predictions})

        except Exception as e:
            logger.error(f"Endpoint hatası: {e}")
            return jsonify({"error": "Sunucu hatası"}), 500

    return app

def main():
    # Kategoriler ve model yolu
    categories = [
        "Atheism", "Graphics", "Windows Misc", "IBM Hardware", "Mac Hardware", 
        "Windows X", "For Sale", "Autos", "Motorcycles", "Baseball", "Hockey", 
        "Cryptography", "Electronics", "Medical", "Space", "Christianity", 
        "Politics - Guns", "Politics - Mideast", "Politics - Misc", "Religion - Misc"
    ]
    model_path = "distilbert_newsgroup_model"  # Güvenli şekilde kontrol edilmeli

    # Flask uygulaması oluşturma
    app = create_app(model_path, categories)

    # Ngrok bağlantısı
    if NGROK_AUTH_TOKEN:
        try:
            ngrok.set_auth_token(NGROK_AUTH_TOKEN)
            public_url = ngrok.connect(5000).public_url
            logger.info(f"Public URL: {public_url}")
        except Exception as e:
            logger.error(f"Ngrok bağlantı hatası: {e}")
    else:
        logger.warning("Ngrok token'ı bulunamadı. Ngrok bağlantısı yapılamayacak.")

    # Uygulamayı çalıştırma
    app.run(port=5000)

if __name__ == "__main__":
    main()
